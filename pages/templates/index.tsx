import Head from "next/head";
import React, { useState, useEffect } from "react";
import PageLayout from "@/components/PageLayout";
import { DividerPipe, FlexColCentered, FlexColCenteredX, FlexColContainer, FlexRowContainer } from "@/components/styled-global-components";
//import { useTranslation } from "next-i18next";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import { GetServerSideProps } from 'next';
//import { translateOrDefault } from "@/utils/i18nUtils";

import tw from "tailwind-styled-components";
import { FaPlus } from "react-icons/fa";

import mockData from "@/mockData/templateText.json"
import ForwardedRefTemplateCard from "@/components/TemplateEditor/TemplateCard";
import CategoryCard from "@/components/TemplateEditor/CategoryCard";
import TemplateNavButton from "@/components/TemplateEditor/TemplateNavButton";

export default function Page() {
  //const { t } = useTranslation("common");
  const [selectedCategory, setSelectedCategory] = useState(0);
  const [textTemplates, setTextTemplates] = useState(mockData.templateText)
  const [templateRefs, setTemplateRefs] = useState<React.RefObject<HTMLDivElement>[]>([]);

  const handleSelectCategory = (index: number) => {
    setSelectedCategory(index);
  }

  /* eslint-disable react-hooks/exhaustive-deps */
  useEffect(() => {
    const newRefs = textTemplates[selectedCategory].templates.map((_, i) => templateRefs[i] || React.createRef());
    setTemplateRefs(newRefs);
  }, [textTemplates[selectedCategory].templates]);
  /* eslint-disable react-hooks/exhaustive-deps */

  const handleInputCatTitleChange = (e: React.ChangeEvent<HTMLInputElement>, index: number) => {
    const newTextTemplates = [...textTemplates];
    newTextTemplates[index].category = e.target.value;
    setTextTemplates(newTextTemplates);
  };

  const handleTextTemplateChange = (categoryIndex: number, templateIndex: number, newTemplate: any) => {
    setTextTemplates(prevTemplates => {
      const newTemplates = [...prevTemplates];
      // Copy the templates array of the category
      const categoryTemplates = [...newTemplates[categoryIndex].templates];
      // Replace the specific template with the new template
      categoryTemplates[templateIndex] = newTemplate;
      // Replace the category's templates array with the modified templates array
      newTemplates[categoryIndex] = {
        ...newTemplates[categoryIndex],
        templates: categoryTemplates,
      };
      return newTemplates;
    });
    console.log(textTemplates)
  };


  const addCategory = () => {
    const newCategory = {
      category: "New Category",
      templates: [],
    };
    const updatedTextTemplates = [newCategory, ...textTemplates];
    setTextTemplates(updatedTextTemplates);
    setSelectedCategory(0);

    //console.log(textTemplates)
  };
  const addTemplate = () => {
    const newTemplate = {
      title: "New Template",
      text: "Click the edit button to create a new template.\n\nUse the hash symbol to create placeholders for your template text.\n\nWhen you save your template, you will see placeholders and input fields for each hash symbol in the template.\n\n An empty placeholder look like this: # \n\n"
    };
    const updatedTemplates = [newTemplate, ...textTemplates[selectedCategory].templates];
    const updatedTextTemplates = textTemplates.map((item, index) => {
      if (index === selectedCategory) {
        return {
          ...item,
          templates: updatedTemplates,
        };
      }
      return item;
    });
    setTextTemplates(updatedTextTemplates);
  };

  const removeTemplate = (index: number) => {
    const updatedTemplates = textTemplates[selectedCategory].templates.filter((_, i) => i !== index);
    const updatedTextTemplates = textTemplates.map((item, index) => {
      if (index === selectedCategory) {
        return {
          ...item,
          templates: updatedTemplates,
        };
      }
      return item;
    });
    setTextTemplates(updatedTextTemplates);
  };

  return (
    <>
      <Head>
        <title>Templates</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <PageLayout>
        <FlexRowContainer className="gap-8 h-full">
          <FlexColCenteredX className="flex-1 max-w-xs gap-4">
            <FlexColCentered className="bg-green-200 w-full p-4 rounded">
              <h2>Categories</h2>
            </FlexColCentered>
            <AddCategoryButton onClick={addCategory} />
            {textTemplates.map((item, index) => {
              return <CategoryCard
                key={"cat-card-" + index}
                index={index}
                category={item.category}
                selectedCategory={selectedCategory}
                handleSelectCategory={() => handleSelectCategory(index)}
                handleInputCatTitleChange={handleInputCatTitleChange}
              />
            })}
          </FlexColCenteredX>
          {textTemplates[selectedCategory].templates.length > 0 && <DividerPipe />}
          {textTemplates[selectedCategory].templates.length > 0 &&
            <FlexColCenteredX className="w-full gap-4 max-w-sm">
              <FlexColCentered className="bg-green-200 w-full p-4 rounded">
                <h2>Navigation</h2>
              </FlexColCentered>
              {textTemplates[selectedCategory].templates.map((template, templateIndex) => (
                <TemplateNavButton
                  template={template}
                  index={templateIndex}
                  categoryIndex={selectedCategory}
                  templateRefs={templateRefs}
                  key={`template-nav-button-${selectedCategory}-${templateIndex}`}
                />
              ))}
            </FlexColCenteredX>
          }


          <DividerPipe />
          <FlexColContainer className="gap-4 w-full">
            <FlexColContainer className="w-full lg:w-[40rem] gap-4">
              <FlexColCentered className="bg-green-200 w-full p-4 rounded lg:w-[35rem]">
                <h2>Templates</h2>
              </FlexColCentered>
              <AddTemplateButton onClick={addTemplate} />
              <FlexColContainer className="max-h-[77vh] overflow-y-auto">
                <FlexColContainer className="gap-4 pe-[4rem]">
                  {textTemplates[selectedCategory].templates.length > 0
                    ? textTemplates[selectedCategory].templates.map((template, templateIndex) =>
                      <ForwardedRefTemplateCard
                        key={`${selectedCategory}-${templateIndex}`}
                        categoryIndex={selectedCategory}
                        index={templateIndex}
                        template={template}
                        removeTemplate={removeTemplate}
                        handleTextTemplateChange={handleTextTemplateChange}
                        ref={templateRefs[templateIndex]}
                      />
                    )
                    : <FlexColCentered className="h-full"><i>Click the add button to create new template</i></FlexColCentered>
                  }
                </FlexColContainer>
              </FlexColContainer>
            </FlexColContainer>
          </FlexColContainer>

        </FlexRowContainer>
      </PageLayout>
    </>
  );
}



const AddButton = tw.button`
  w-full
  bg-gray-200
  text-gray-800
  dark:text-gray-200
  dark:bg-gray-700
  rounded
  p-4
  hover:text-gray-400
  hover:bg-gray-300
  hover:dark:text-gray-300
`

const AddCategoryButton = ({ onClick }: any) => {
  return <AddButton onClick={onClick}>
    <FlexColCentered>
      <FaPlus />
    </FlexColCentered>
  </AddButton>
}

const AddTemplateButton = ({ onClick }: any) => {
  return <AddButton className="lg:w-[35rem]" onClick={onClick}>
    <FlexColCentered>
      <FaPlus />
    </FlexColCentered>
  </AddButton>
}




export const getServerSideProps: GetServerSideProps = async ({ locale }) => {
  return {
    props: {
      ...(await serverSideTranslations(locale as string, ["common"])),
    },
  };
};
